## 字符输入/输出和输入验证
## 主要内容
- 输入，输出，缓冲输入和无缓冲输入的区别
- 通过键盘模拟文件结尾条件
- 使用重定向把程序和文件相连接
- 创建友好的用户界面
## 缓冲区
- 无缓冲输入，程序可立即使用该内容
- 缓冲输入分为 完全缓冲I/O 和 行缓冲I/O
- 完全缓冲是指当缓冲区被填满时才刷新缓冲区，通常出现在文件输入中
- 键盘输入通常是行缓冲输入
## 结束键盘输入
### 文件、流和键盘输入
- 打开文件的过程就是把流与文件相关联，而且读写都是通过流来完成
- C把输入和输出设备视为存储设备上的普通文件，把键盘和显示设备视为每个C自动打开的文件
- stdin流代表键盘输入，stdout代表屏幕输出
- 可以用处理文件的方式处理键盘输入，（需要让C知道文件何时结尾）
### 文件结尾
如今，操作系统使用内嵌的`CTRL+Z`字符来标记文件结尾
其他方法
- 文件末尾标记特殊字符
- 记录文件的大小，存储文件的大小信息
---
- 用`getchar(),scanf()`读取文件检测到文件结尾时将返回EOF(end of file)
- EOF定义在stdio.h中，`#define EOF (-1)`
- 为什么是-1，getchar()通常返回值是0~127，最多0~255，无论哪种情况，-1也不代表任何字符
- `while((ch = getchar())!= EOF)`，判断文件是否到达结尾
//注意getchar返回的是int类型，所以要把ch声明为int类型
---
- 在大多数UNIX和linux系统中，在一行开始处按`CTRL+D`会传输文件结尾信号
- 在PC中，按`CTRL+Z`是文件结尾信号
## 重定向和文件
程序可以通过两种方式使用文件
1. 显式使用特定的函数打开文件、关闭文件、读取文件、写入文件（详见13章）
2. 设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出，即把stdin流重新赋给文件
---

1. ==重定向输入==
```c
有words.txt
已经编译了echo_eof.c,生成了echo_eof(.exe),运行该程序，输入  ./echo_eof
如果想让echo_eof读取words.txt中的输入，而不是键盘，需要将words文件和stdin流相关联（默认关联键盘）
./echo_eof < words

```
2. ==重定向输出==
./echo_eof > mywords 创建一个mywords新文件，把echo_eof输出重定向至该文件
3. ==组合重定向==
./echo_eof < mywords > savewords //顺序无关

注意： ./echo_eof < mywords > mywords 是错误的，> mywords在输入之前已导致原mywords的长度被截断为0
==不能两个输入，不能两个输出，重定向运算符连接一个可执行程序和一个数据文件==

- `>>`运算符，把数据添加到现有文件的末尾；| 运算符，把一个文件的输出连接到另一个文件的输入
经典例题[^1]
[^1]:file_eof.c P193 
## 创建友好的用户界面
经典例题[^2]

[^2]: P194-P206

## 输入验证
经典例题[^3]

[^3]: P194-P206

## 菜单浏览
学会写伪代码