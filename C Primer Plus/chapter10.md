
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [数组和指针](#数组和指针)
  - [主要内容](#主要内容)
  - [数组](#数组)
    - [初始化](#初始化)
    - [给数组元素赋值](#给数组元素赋值)
    - [数组边界](#数组边界)
    - [指定数组大小](#指定数组大小)
    - [多维数组](#多维数组)
  - [初始化二维数组](#初始化二维数组)
    - [两种初始化方法](#两种初始化方法)
  - [指针和数组](#指针和数组)
    - [函数、数组和指针](#函数-数组和指针)
    - [声明和定义数组形参](#声明和定义数组形参)
    - [使用指针形参](#使用指针形参)
    - [指针](#指针)
    - [保护数组中的数据](#保护数组中的数据)
    - [const](#const)
  - [指针和多维数组](#指针和多维数组)
    - [指向多维数组的指针](#指向多维数组的指针)
    - [指针兼容性](#指针兼容性)
    - [函数和多维数组](#函数和多维数组)
    - [变长数组](#变长数组)

<!-- /code_chunk_output -->


# 数组和指针
## 主要内容
static & * 创建和初始化数组
## 数组
`float candy[365]`365代表元素个数
- const声明数组，创建只读数组，应该用const声明和初始化数组
const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31};

### 初始化
- 使用数组之前必须初始化，若未进行初始化，编译器使用的值是内存相应位置的现有值
- 如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值；若部分初始化数组，剩余的元素就会被初始化为0
- 本章描述的数组是自动存储类别，意思是数组在函数内部声明，且在声明时未使用关键字static
1. int power[8] = {1,2,3,4,5,6,7,8};
2. C99指定初始化器，可以初始化指定的数组元素，`int arr[6] = {[5]=212};`把arr[5]初始化为212
### 给数组元素赋值
- 借助数组下标给数组元素赋值
### 数组边界
在使用数组时，要防止数组下标超出边界
- 数组元素编号从0开始，最后是在声明数组时，使用符号常量来表示数组的大小
```c
#define SIZE 4
int main(void)
{
    int arr[SIZE];
    for(i=0;i<SIZE;i++)
    ... 
}
```
### 指定数组大小
C99支持变长数组
```c
int n=5;
int m=8;
float a8[n];
float a9[m];
```
### 多维数组
- 背景：60个数组，创建5个数组，每个数组包含12个元素
- 多维数组，数组的数组，主数组有5个元素，每个元素是内含12个元素的数组
```c
float rain[5][12];
rain是一个内含5个元素的数组，rain[0]是一个内含12个float类型值的数组
```
## 初始化二维数组
```c
const float rain[YEARS] [MONTHS]=
{
    {1,2,3,4,5,6,7,8,9,10,11,12},
    {1,2,3,4,5,6,7,8,9,10,11,12},
    {1,2,3,4,5,6,7,8,9,10,11,12},
    {1,2,3,4,5,6,7,8,9,10,11,12},
    {1,2,3,4,5,6,7,8,9,10,11,12}
};
```
### 两种初始化方法
1. `int sq[2] [3]={{5,6},{7,8}};`
2. `int sq[2] [3]={5,6,7,8};`
可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表
## 指针和数组
1. 数组名是数组首元素的地址
2. flizny == &flizny[0]
3. 指针+1是指的是增加一个存储单元，指针的值递增它所指向类型的大小，对数组而言，意味着加1后的地址是下一个元素的地址
4. 许多计算机都是按字节编址，意思是内存中每个字节都按顺序编号
```c
dates + 2 == &dates[2]
*(dates + 2) == dates[2]
即*(ar + i) == ar[i]
  ar + i == &ar[i]
```
```c
区分
*(dates + 2) 
*dates + 2（第一个元素的值+2）
```
### 函数、数组和指针
- 数组名是数组首元素的地址
- int *ar形式和int ar[]形式都表示ar是一个指向int的指针，但是int ar[]只能用于声明形式参数
---
### 声明和定义数组形参
1. int sum(int *ar，int n);
        int sum(int *ar，int n)
2. int sum(int ar[],int n);
        int sum(int ar[],int n)
### 使用指针形参
- sum()使用一个指针形参标识数组的开始，使用一个整型参数表示待处理数组元素的个数
- 传递两个指针，第一个指针表明数组的开始处，第二个指针指明数组的结束处
```c
total += *start++;
一元运算符*和++优先级相同，但是结合律是从右往左的，所以具体执行过程是如何
*(start++)//这样更清楚
```
### 指针
- 转换符 %p
- 创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存，因此，在使用指针之前，必须先用已分配的地址初始化它。
指针的第一个用法是在函数间传递信息
指针的第二个用法是用在处理数组的函数中
### 保护数组中的数据
- 只有程序需要在函数中改变该数值时，才会传递指针。对于数组，必须传递指针
- const告诉编译器，该函数不能修改ar指向的数组中的内容
- const不是要求原数组是常量，而是该函数在处理数组时，将其视为常量，不可更改。
- 如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明形参时最好使用const
### const
1. const double PI = 3.1415;  
2. const int days[MONTHS]={1,2,3,4,5,6,7,8,9,10,11,12};
---
1. 
double rates[5]={1,2,3,4,5};
const double *pd=rates;//不能使用pd来更改它所指向的值
rates[0]=99.99;//允许，因为rates未被const限定  

2. 
double *const pc = rates;//用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址

3. 
在创建指针时，可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值
const double *const pc = rates;

---
- 总结
1. 把const数据或者非const数据的地址初始化为指向const的指针或者为其赋值是合法的
2. 只能把非const数据的地址赋给普通指针
## 指针和多维数组
int zippo[4] [2];
- zippo[0]的值和它首元素的地址(&zippo[0] [0])相同
- zippo是一个占用两个int大小对象的地址
- zippo和zippo[0]值相同
- zippo+1和zippo[0]+1不同
- *(zippo[0]) 即 zippo[0] [0]的上的值
- *zippo 即 zippo[0]的值 即&zippo[0] [0]
- **zippo和 *&zippo[0] [0]等价 即zippo[0] [0]
- zippo是地址的地址，必须解引用两次才能获得原始值
- 如果程序使用指向二维数组的指针，当需要通过指针取值时，最好用数组表示法
### 指向多维数组的指针
==int (*pz)[2];== 指向数组的指针
==int *pz[2];==怎么想，先把[2]去掉，就是一个int指针，加上[2]就是包含两个int指针的数组  

---
zippo[m] [n]==*(*(zippo+m)+n)
pz[m] [n]==*(*(pz+m)+n)
### 指针兼容性
- int **p2;
- 把const指针赋值给非const指针不安全
### 函数和多维数组
```c 
int *pt 等价于 int pt[]
int (*pt)[4] 等价于 int pt[] [4]
```
### 变长数组